<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Litao.Me</title>
 <link href="http://litao.me/atom.xml" rel="self"/>
 <link href="http://litao.me/"/>
 <updated>2012-09-25T21:52:54+08:00</updated>
 <id>http://litao.me/</id>
 <author>
   <name>EaHydra</name>
   <email>xxeaglenet@gmail.com</email>
 </author>

 
 <entry>
   <title>新的开始</title>
   <link href="http://litao.me/2012/09/16/begin.html"/>
   <updated>2012-09-16T00:00:00+08:00</updated>
   <id>http://litao.me/2012/09/16/begin</id>
   <content type="html">&lt;h2&gt;关于WordPress&lt;/h2&gt;

&lt;p&gt;之前一直在用WORDPRESS搭建自己的博客，用了一年多了。但是一直觉着不太满意，一是因为WORDPRESS有点
太复杂，比如编辑文章繁琐，有点象用WORD，但是又没WORD那么多功能。二呢，就是因为WORDPRESS的皮肤。虽然有很多皮肤，但是还不是自己想要的。一直想要的博客样式是那种首页大部分空白，只有文章列表，有一些PAGES的链接，有一个简洁明了的ABOUT ME，打开一篇文章，没有其他，只有文章内容。而WORDPRESS一些自有的东西限制了这些。也许有能满足我的WORDPRESS THEME，但是我真的没太多时间去找这些THEME，我只想把自己的经验和收获记录下来，然后分享到网络上。&lt;/p&gt;

&lt;h2&gt;关于Markdown&lt;/h2&gt;

&lt;p&gt;前些天在网络上瞎逛，想看下MAC中常用的软件，众所周知，APPLE出品的东西都是非常棒的，属于精品系列。而且MAC下的应用做的也很棒。结果就看到了&lt;strong&gt;MARKDOWN&lt;/strong&gt;。当我使用&lt;strong&gt;MARKDOWN&lt;/strong&gt;后，特别兴奋，忍不住跟周围的同事，我的女朋友分享了这个东西。&lt;strong&gt;MARKDOWN&lt;/strong&gt;真的非常棒。它让我解脱了WORD对我的束缚。前段时间，在写生详设文档的时候，总是想着这个段落怎么分，那个标题要多大，还要调整下自动分段.总是没办法让我流畅的写我想写的.&lt;br/&gt;
而&lt;strong&gt;MARKDOWN&lt;/strong&gt;对我来说犹如甘露，它的语法是那么简洁，在你写作的时候，形如流水。又因为支持HTML，CSS，可以事后根据自己的喜好进行排版。真恨自己不早点接触到&lt;strong&gt;MARKDOWN&lt;/strong&gt;.&lt;br/&gt;
关于&lt;strong&gt;Markdown&lt;/strong&gt;的语法请&lt;a href=&quot;http:markdown.tw/&quot;&gt;点这&lt;/a&gt;.
关于&lt;strong&gt;Markdown&lt;/strong&gt;的编辑工具主要有&lt;a href=&quot;http://markdownpad.com/&quot;&gt;MarkdownPad&lt;/a&gt;, &lt;a href=&quot;http://mouapp.com/&quot;&gt;Mou&lt;/a&gt;, &lt;a href=&quot;http://Sublimetext.com&quot;&gt;Sublime Text&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;关于Jekyll&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/mojombo/jekyll&quot;&gt;Jekyll&lt;/a&gt;支持&lt;strong&gt;Markdown&lt;/strong&gt;,支持&lt;strong&gt;&lt;a href=&quot;http://https://github.com/mojombo/jekyll/wiki/Liquid-Extensions&quot;&gt;Liquid&lt;/a&gt;&lt;/strong&gt;。Jekyll+Markdown，这就是我想用的BLOG。所以我从WORDPRESS上转过来了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Open registry key in regedit.exe</title>
   <link href="http://litao.me/2012/04/25/open-registry-key-in-regedit-exe.html"/>
   <updated>2012-04-25T00:00:00+08:00</updated>
   <id>http://litao.me/2012/04/25/open-registry-key-in-regedit-exe</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;Usage: regjump.exe HKEY_LOCAL_MACHINE\SOFTWARE&lt;/strong&gt;&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/3747786.js&quot;&gt; &lt;/script&gt;

</content>
 </entry>
 
 <entry>
   <title>如何自动获取网络变化通知</title>
   <link href="http://litao.me/2012/04/23/How-to-Get-Network-Change-automation.html"/>
   <updated>2012-04-23T00:00:00+08:00</updated>
   <id>http://litao.me/2012/04/23/How-to-Get-Network-Change-automation</id>
   <content type="html">&lt;p&gt;当我们把网线插到计算机上时，WINDOWS任务栏的托盘图标都会更改相应的网络图标，拔掉也会有相应的处理。一直都对这个机制感兴趣，却不知道如何做，而且公司的某个产品也需要这么一个功能。昨天在家测试某个程序的时候，发现了其中一个线程的栈中有一个叫wininet!CheckForNetworkChange的函数，IDA分析了WINNET.DLL后，有了本文。&lt;/p&gt;

&lt;p&gt;微软在WINDOWS VISTA之后提供了一个叫NLA(Network List Manager API)的接口，用于获取网络状态变化通知的一个接口。以COM技术实现。
主要导出的COM接口如下：&lt;/p&gt;

&lt;pre&gt;
IEnumNetworkConnections
IEnumNetworks
INetwork
INetworkConnection
INetworkConnectionEvents
INetworkEvents
INetworkListManager
INetworkListManagerEvents
&lt;/pre&gt;


&lt;p&gt;其中INetworkListManager是一个根对象，可以获取计算机是否连接到因特网(INetworkListManager-&gt;get_IsConnectedToInternet)。还可以查询有哪些可用的网络和连接.更关键的是INetworkListManagerEvents和INetworkEvents两个类。这两个类在MSDN文档里的描述如下：&lt;/p&gt;

&lt;pre&gt;
is a message sink interface that a client implements to get overall machine state related events.
&lt;/pre&gt;


&lt;p&gt;也就是说我们要自己实现这两个类。而回调的方式是通过COM技术中特有的机制IConnectionPoint来搞定。实现方式如下：&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/3747800.js&quot;&gt; &lt;/script&gt;


&lt;p&gt;因为NLA API是WINDOWS VISTA之后才有的，对于WINDOWS XP是不兼容的，但是WINDOWS XP下有一个方法可以达到同样的效果，可以参考文章&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms700657(v=vs.85&quot;&gt;Network Awareness in Windows XP&lt;/a&gt;.aspx)，这个文章里的代码是C#的，其中关键的代码转换成C++:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/3747803.js&quot;&gt; &lt;/script&gt;

</content>
 </entry>
 
 <entry>
   <title>一次死锁的分析</title>
   <link href="http://litao.me/2012/04/19/analyze-dead-lock.html"/>
   <updated>2012-04-19T00:00:00+08:00</updated>
   <id>http://litao.me/2012/04/19/analyze-dead-lock</id>
   <content type="html">&lt;p&gt;做了半年的产品最近在实测阶段，QC报告有些用户出现升级版本后，CPU高占，一直不出现界面的问题。因为出现的比例很小，很难排查。昨天又出现一次这样的问题，远程抓取DUMP到本地分析。
抓DUMP的方法比较简单，用WINDBG里的脚本&lt;strong&gt;ADPLUS.VBS -hang -o c:\123 -pn 进程名&lt;/strong&gt;，即可抓取。前后抓两次，可以相互比较。&lt;/p&gt;

&lt;p&gt;先后加载两个DUMP文件，调用!runaway命令查看哪个时间最长，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 
0:000&gt; !runaway  
 User Mode Time  
  Thread       Time  
  14:1e0       0 days 0:14:14.859  
  23:584       0 days 0:00:00.296  
  22:24c       0 days 0:00:00.171  
   0:708       0 days 0:00:00.078  
  27:280       0 days 0:00:00.046  
  21:4d8       0 days 0:00:00.046  
  28:35c       0 days 0:00:00.031  
  19:200       0 days 0:00:00.015  
  15:1cc       0 days 0:00:00.015  
  26:1a8       0 days 0:00:00.000  
  25:738       0 days 0:00:00.000  
  24:550       0 days 0:00:00.000  
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;&lt;/p&gt;

&lt;br/&gt;


&lt;pre&gt;&lt;code&gt;  
0:000&gt; !runaway
 User Mode Time
  Thread       Time
  14:1e0       0 days 0:14:14.859
  23:584       0 days 0:00:00.296
  22:24c       0 days 0:00:00.171
   0:708       0 days 0:00:00.078
  27:280       0 days 0:00:00.046
  21:4d8       0 days 0:00:00.046
  28:35c       0 days 0:00:00.031
  19:200       0 days 0:00:00.015
  15:1cc       0 days 0:00:00.015
  26:1a8       0 days 0:00:00.000
  25:738       0 days 0:00:00.000
  24:550       0 days 0:00:00.000
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;分析发现，是线程1E0跑的时间最长，切到线程1E0后，栈上下文如下，以最后DUMP为准：&lt;br/&gt;
&lt;img src=&quot;/images/1e0-stack.png&quot; alt=&quot;&quot; /&gt;&lt;br/&gt;
其中TAMInstance!CTestAliveMgr::NotifyEvent函数是负责检查进程内运行的线程是否死锁或者运行时间过长，如果时间过长，最终会调用CTestAliveMgr::ProcessExpireMgr处理线程超时，内部会调用CTestAliveMgr::DumpRunningStatus处理。观察这个上下文，发下OpenThread失败，一般来说，这个API失败，一般是目标线程不存在了。我观察线程列表发现，这个线程还活着，当时认为是内核出问题了。因为这个产品有一些安全相关的驱动模块，打开用户的任务管理器，查看CPU使用情况，发现CPU高占的同时，内核时间也占了一个很大的比例，以为是内核出了问题，后来找相关驱动开发人员询问得知这种问题应该也不存在，所以忍不住想看下OpenThread要打开的目标线程是什么情况。从栈的上下文里可以知道是要打开1A8这个线程。
切换到线程1A8，栈的上下文如下：&lt;br/&gt;
&lt;img src=&quot;/images/1a8-stack.png&quot; alt=&quot;&quot; /&gt;&lt;br/&gt;
这个线程要去用ShellExecute去调用Regsvr32.exe去注册一个COM组件，然后发现内部最终会触发一个动态库加载动作，栈的最顶端有一个临界区等待的动作。按照微软的文档&lt;a href=&quot;http://download.microsoft.com/download/a/f/7/af7777e5-7dcd-4800-8a0a-b18336565f5b/dll_bestprac.doc&quot;&gt;《Best Practices for Creating DLLs》&lt;/a&gt;中的说法，一个DllMain内部是不可以有加锁动作的，但是在这个例子中加载了shdocvw.dll，进入DllMain，最终却引发了锁动作，应该提高警惕。
用!cs指令查看这个临界区被线程0×738拿到，切换到线程0×738，上下文如下：&lt;br/&gt;
&lt;img src=&quot;/images/738-stack.png&quot; alt=&quot;&quot; /&gt;&lt;br/&gt;
可以看到，这个线程想获取某个DLL的导出函数指针，GetProcAddress内部会调用ntdll!LdrpGetProcedureAddress,这个函数内部会拿一个全局锁，用于保证DLL加载数据同步用的，这个锁已经被线程1A8拿到了.而且分析这个上下文，可以知道，这个线程内部调用了shlwapi.dll中的函数，这个函数内部已经拿到了线程1A8想拿的锁，这样就造成了死循环，两个线程始终都拿不到这个各自想要的锁，也就是死锁。&lt;/p&gt;

&lt;p&gt;解决方法是避免在进程运行中途加载shdocvw.dll，所以我在进程初始化时就把这个DLL给加载进来，这样就避免shdocvw.dll!DllMain函数内部拿锁的动作。&lt;br/&gt;
另外就是，分析整个DUMP下来，最终都是因为ShellExecute函数导致，这个接口虽然很强大，但是做了太多的事情，而且机制也够复杂.最近碰到的几个问题都与这个有关。建议不要使用。shell api本身是给EXPLORER使用的，里面的很多机制都是为了EXPLORER准备的，贸然使用可能会有很多问题。&lt;br/&gt;
关于ShellExecute的问题，还有一个例子，在《WINDOWS高效排错》一书里，提到打开一个东西，却打开UE编辑器两次.更神奇的是，这种问题我们这边遇到过.在我们自己的程序里需要打开IE展现指定的搜索页，结果QC报告，出现过点击一次展示，却出现两个相同搜索页的问题。后来调试的时候，发现只要在运行ShellExecute的地方，单步跟踪，就可能打开两个页面。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Use __declspec(thread) in dll occured Exception</title>
   <link href="http://litao.me/2012/03/05/use_declspec_thread_in_dll.html"/>
   <updated>2012-03-05T00:00:00+08:00</updated>
   <id>http://litao.me/2012/03/05/use_declspec_thread_in_dll</id>
   <content type="html">&lt;p&gt;今天在写一个缓存的东西的时候，因为场景比较简单，特殊，所以决定借用TLS来处理数据的同步。&lt;br/&gt;
刚开始用__declspec(thread)声明TLS变量，在WIN7下跑着很欢畅，但是在XP下一跑就挂鸟。&lt;br/&gt;
DEBUG发现，声明的变量内存地址无效，也就是说系统没有为该TLS变量申请内存。GOOGLE没看到有用的信息，最后在微软的KB库中
发现如下一文:&lt;a href=&quot;http://support.microsoft.com/kb/118816/en-us&quot;&gt;PRB: Calling LoadLibrary() to Load a DLL That Has Static TLS&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Cause&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;This is a limitation of LoadLibrary and __declspec. The global variable space for a thread is allocated at run time. The size is based on a calculation of the requirements of the application plus the requirements of all of the libraries that are statically linked. If a DLL uses static TLS and is dynamic-linked in an application, when LoadLibrary or FreeLibrary is called, the system must find all the threads that exist in the process and enlarge or compact their TLS memory according to the size of static TLS in the newly loaded DLL. This process is too much for operating systems to manage, which can cause an exception either when the DLL is dynamically loaded or code references the data.&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;Resolutions&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;DLLs that use __declspec(thread) should not be loaded with LoadLibrary.
The DLL code should be modified to use such TLS functions as TlsAlloc, and to allocate TLS if the DLL might be loaded with LoadLibrary. Or, the DLL that is using __declspec(thread) should only be implicitly loaded into the application.&lt;/p&gt;&lt;/blockquote&gt;
</content>
 </entry>
 
 <entry>
   <title>我们为什么要分享</title>
   <link href="http://litao.me/2011/11/12/Why-do-we-want-to-share.html"/>
   <updated>2011-11-12T00:00:00+08:00</updated>
   <id>http://litao.me/2011/11/12/Why-do-we-want-to-share</id>
   <content type="html">&lt;p&gt;看到了一篇文章&lt;a href=&quot;http://www.managershare.com/2011/11/11/why-should-we-share/&quot;&gt;《我们为什么要分享》&lt;/a&gt;，感觉不错，转载给大家。&lt;br/&gt;
很多读者在问，我们为什么要做这个经理人分享站，借用李衍忠先生的这个演讲，来表达一下我们的建站夙愿，也送给所有和我们一样有分享之心的同仁！&lt;/p&gt;

&lt;p&gt;人是群居的动物，人与人应该怎么相处，彼此之间该怎么说话，都是一门大学问。做人难、说话更难，可是我们都想获得快乐，那该怎么办呢？凉爽的冷气、丰盛的食物，这些物质的东西都只是快乐的一部分而已，关键的部分其实在于我们该怎么调整内心的情绪，让自己变得更快乐。&lt;br/&gt;
　　当我们跟别人相处的时候，往往会认为“因为我跟你的身体是分开的，所以我跟你是分开的”、“人与人都是分开的”。所以当我们想获得快乐时，就希望别人不要阻碍我，或索性筑起一座高墙，防止别人爬进我的领域，最好墙外还要有一条护城河和吊桥，我想出去的时候把吊桥放下，回来了再赶紧把吊桥收起来。其实这种想法是很大的错误，因为在生命的交流上，人与人每一剎那都连接在一起，只是我们不明白这个特质。
　　中国儒家思想讲“仁”，就是在讲两个人的关系，人与人的关系怎么样才能变好？就是要“己利利人，己达达人”，我希望得到的，希望你也能得到，我希望了解的，希望你也能了解。当我们自己得到一分知识和快乐，再将它当作礼物分享给别人的时候，你会发现，你回收的不只有一分，而是很多很多的知识和快乐。　　举一件我最近遇到的事情为例：有一天，我从高雄搭火车到台中。我坐在靠走道的位置，对面坐着一位阿妈，她的手臂上有些用原子笔写的字，看起来像刺青一样，我觉得好奇，盯着看可是不敢问，因为我这种人是习惯与人保持距离的，所以只有冷眼旁观。&lt;br/&gt;
　　过了一会儿，来了一个年约三十多岁的小姐，坐到阿妈身边，她一坐下来就很热心地问阿妈：“阿妈！你要去哪里？”然后两个人就开始聊起天来。&lt;br/&gt;
　　我旁边也有一个空座位，虽然我一度希望这个位子不要坐人，但是后来还是坐了一位先生。我想他大概跟我一样，也是中规中矩、绅士型的人，打了一条领带，我也打了一条领带。我从头到尾都没看到他看我，当然，我也绝对不会看他，但是我们彼此偶尔都会互瞄一下，我看到他在读一本张忠谋的书，我也在读我带的书。&lt;br/&gt;
　　因为阿妈跟小姐坐在我面前，所以我可以听见她们的对话：那个小姐是从美国回台湾度假的，回来三个礼拜，跟她先生去过垦丁和澎湖玩，她讲了许多关于这三个礼拜的故事给阿妈听，还把两个女儿的照片拿给阿妈看，跟阿妈分享她的喜悦。阿妈看照片的时候还高兴地说：“喔！这是圣诞节拍的啊！”
　　那么阿妈手臂上的刺青是怎么来的呢？原来她要去台中探望亲人，可是以前没去过那个地方，出发的时候就很勇敢地在火车站跟陌生人问路，人家告诉她该怎么走，她怕忘记，所以对方就想把简单的位置写在她手上，可是阿妈担心等一下上厕所会把字给洗掉，所以就请他帮忙把字写在她的手臂。两个人就这样一路聊，两个半钟头后已经变成好朋友了，分别前阿妈还跟小姐说：“妳真是一个知书达礼的人啊！”
　　一路上我在旁边听得很感动，因为我看到两种截然不同的人际关系；一种是时时刻刻乐意打开自己的生命世界，告诉别人自己的想法；另一种则是时时刻刻装扮自己，也许打一条领带还不够，还要穿西装、别一枝金色的笔，让人感觉“我很绅士”，可是生命型态就是“我坐在这里，我多么盼望别人来赞美我、肯定我一下啊！”后面这种想法，使我们跟这个世界的距离越来越远……
　　我们都希望别人对我好，都想：“如果你对我好，我一定对你好”，可是正因为大家都这么想，所以大家都坐在那里等待别人对我好。当每个人都这么想时，这个世界就变得非常冷漠。其实我们周遭的人并不恐怖，我们是被自己的恐惧淹没了生命世界，常常假想：周遭的人是冷漠的、周遭的人如何如何，当我们越这样假想，心也越来越冷，因为你把自己的眼睛涂成灰色，所以看出去的世界都变成灰色。
　　真正的问题不是这个世界变成灰色，而是你没有去寻找、去付出美丽的东西，当你付出美丽的东西时，即使对方是一个不好的人，可是他面对你的善良，他也会拿出他善良的一面跟你对应。每个人的人性都有这种特质：你给他快乐，他就会回馈你快乐。&lt;br/&gt;
　　我们每天都在想：“我要怎么样才会获得快乐？”又想：“谁也不要侵犯我！”，“我”想得越多，越小心保护自我，神经也愈紧绷。事实上，如果真的想要生活得愉快，就应该把“我”改成“我们”，想想“他跟我是一体的，我们是好朋友”，这样一来到处都存在着“我们”，分享苦乐的人就会愈来愈多，每个人的快乐我都可以分享到，生命自然更开阔。&lt;br/&gt;
&lt;strong&gt;台中福智学苑主任 李衍忠演讲&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Nginx 1.0.5 in windows heap corruption</title>
   <link href="http://litao.me/2011/08/22/nginx-1.0.5-in-windows-heap-corruption.html"/>
   <updated>2011-08-22T00:00:00+08:00</updated>
   <id>http://litao.me/2011/08/22/nginx-1.0.5-in-windows-heap-corruption</id>
   <content type="html">&lt;p&gt;昨晚测试Nginx 1.0.5 For Windows版本，开启代理缓存功能后发现了一个堆溢出BUG。&lt;/p&gt;

&lt;p&gt;问题发生在src/os/win32/ngx_file.c line 224 ngx_win32_rename_file()处。原有的申请内存代码如下：&lt;br/&gt;
Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;br/&gt;


&lt;p&gt;因为长度计算错误，少算一个字节，导致在后面调用
Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;br/&gt; 


&lt;p&gt;内存越界，观察内存发现，覆盖了一个字节。在原有代码基础上多加一个字节，之后测试OK。提交给Nginx官方后，得到了响应，修补的方法如下：&lt;br/&gt;
Liquid error: No such file or directory - pygmentize&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PE File Checksum Algorithm</title>
   <link href="http://litao.me/2011/06/28/PE-File-Checksum-Algorithm.html"/>
   <updated>2011-06-28T00:00:00+08:00</updated>
   <id>http://litao.me/2011/06/28/PE-File-Checksum-Algorithm</id>
   <content type="html">&lt;p&gt;这两天闲来无事，在看PE文件相关的文章，我们知道PE文件是有校验和算法的，而且像驱动，或者系统DLL之类的特殊执行文件，对校验和的要求是极其高的，如果没算对，就认为是非法文件。微软SDK里提供一个API，叫MapFileAndCheckSum，这个可以计算出一个PE文件的校验和，该API的相关分析，可以参考这篇文章&lt;a href=&quot;http://www.codeproject.com/KB/cpp/PEChecksum.aspx&quot;&gt;《An Analysis of the Windows PE Checksum Algorithm》&lt;/a&gt;。关于校验和算法，还有一个比较有意思的算法是IP协议的校验和算法，可以看&lt;a href=&quot;http://datatracker.ietf.org/doc/rfc1071/?include_text=1&quot;&gt;RFC 1071&lt;/a&gt;。还有WIKI中的这篇文章&lt;a href=&quot;http://en.wikipedia.org/wiki/Redundancy_check#Error_detection_schemes&quot;&gt;《Error detection and correction》&lt;/a&gt;。&lt;br/&gt;
我感觉这个应用层实现的PE CHECK SUM算法太过恶心了..就看了下系统内核PE加载器的内核实现，发现校验和算法部分和应用层的完全不同，比应用层的简洁多了，直接上代码:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/3747774.js&quot;&gt; &lt;/script&gt;

</content>
 </entry>
 

</feed>
